package example.item18;

/*
 *  아이템 18. 상속보다는 컴포지션(합성)을 사용하라.
 *
 *  - 서론
 *  객체는 자기 자신을 책임질 수 있는 자율적인 존재여야 하고, 높은 응집도와 다른 모듈간의 낮은 결합도를 유지하면서 변경의 전파를 제어하는 적절한 장치들을 통해 캡슐화되어야 한다.
 *  응집도가 높고 결합도가 낮은 클래스들은 구성이 깔끔해져서 이해하기 쉽고, 재사용하기 쉬우며, 변화에 대응하는 속도가 높아지고, 기능의 확장 및 유지보수에도 매우 편리하다.
 *
 *  - 본론
 *  하지만 객체지향 패러다임에 등장하는 상속(inheritance)은 잘못 사용할 경우에 이러한 틀을 깨 버릴수 있다.
 *  무조건적으로 상속이 나쁘다는 것은 아니지만 상속의 문제점들을 모두 피해가는 묘안이 하나있다.
 *  기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하는 방법이다.
 *  기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(composition; 합성 또는 구성)이라 한다.
 *  새 클래스의 인스턴스 메서드들은(private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.
 *  이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다.
 *  그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.
 *
 *  - 결론
 *  상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.
 *  is-a 관계일 때도 안심할 수만은 없는게, 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 문제가 될 수 있다.
 *  상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
 *  컴포지션대신 상속을 사용하기로 결정하기 전에 다음 질문들을 자문해보면 도움이 될 것이다.
 *  확장하려는 클래스의 API에 아무런 결함이 없는가? 결함이 있다면, 이 결함이 다른 클래스의 API까지 전파되어도 괜찮은가?
 *
 *  컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 그 결함까지도 그대로 계승한다.
 *
 *  📍 참고
 *  응집도란 '프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도'이다.
 *  즉, 높은 응집도란 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻입니다.
 *  결합도란 '하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도'이다.
 *  즉, 낮은 결합도란 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에대한 요구가 전파되지 않는 상태를 말한다.
 */
public class Item18 {
}
